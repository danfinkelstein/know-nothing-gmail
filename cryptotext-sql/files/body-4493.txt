I'm not sure I know why stat64 is being called. It could be that one of your new instructions isn't what you think it is and the program execution path changes to some error handler, or something else. You probably want to create an instruction trace and make sure it's doing what you think it is. If that is the case then implementing stat64 shouldn't be that difficult, just take a look at fstat64. stat64 is the same thing but instead of argument 1 being a file descriptor it's a path to a file.Ali- Show quoted text -On Jun 12, 2007, at 8:14 PM, Jiayuan Meng wrote:Hi all, As I am trying to run a thread in SE mode, I made up the following code: void thread_main(){    int* x = new x[10];    delete [] x;    my_exit(); // inlined assembly(asm volatile (".byte 0x61, 0x00,0x00,0x40))} main(){    launch(&thread_main); // inlined assembly(asm volatile (".byte 0x62, 0x00,0x00,0x40))    wait(); // inlined assembly(asm volatile (".byte 0x63, 0x00,0x00,0x40))} To launch this thread, what I did was: allocate a stack, assign the pc, and activate the thread context on another cpu. my_exit() will tell the simulator that this thread is finished and the simulator will deallocate/halt its thread context. The extened assemblies are implemented following the M5FUNC pseudo instructions. I use crosstool's g++ 3.4.3 to compile the code to alpha-linux. M5 is compiled on a 64bit x86 machine. I get the following message:fatal: syscall stat64 (#425) unimplemented. how ever, if I just change the thread_main to:void thread_main(){    int* x = new x    delete x;    my_exit();}  The error will be gone. What can I do to allow the first case to work? is there any patch for system call stat64? Thanks! Jiayuan_______________________________________________
m5-users mailing list
m5-users@m5sim.org
http://m5sim.org/cgi-bin/mailman/listinfo/m5-users
