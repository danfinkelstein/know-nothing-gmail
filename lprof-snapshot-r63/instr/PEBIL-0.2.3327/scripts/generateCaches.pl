#!/usr//bin/perl

use Getopt::Long;
use strict;

my $cache_desc_file = "CacheDescriptions.txt";
my $output_file_name = "CacheStructures.h";


sub powerOfTwo {
    my $val = shift @_;
    my $check = 1;
    my $power = 0;
    while($val >= $check){
        if($val == $check){
            return $power;
        }
        $power++;
        $check = $check * 2;
    }
    return -1;
}

my @system_caches = ();

my $help_string = <<HELP_STR;

usage : $0
   [--sys-file <cache_desc_file>]  <-- defaults to CacheDescriptions.txt
   [--out-file <outfile>]          <-- defaults to CacheStructures.h
   [--stride-sys <system idx>]     <-- defaults to 0, 2 MB direct cache
   [--nostd]                       ? static allocation of cache structures and use of safe lib functions
   [--puniq]                       ? print unique cache information.
   [--help]
   [--readme]

HELP_STR

my $readme_string = <<README_STR;

This script generates a C header file that contains cache structures from 
a given text file. The C header file is used by the cache simulator tool
generated by PMaCInstrumentor binary instrumentation library. 

--sys-file <cache_desc_file>
============================
This file contains the cache descriptions for the systems in consideration.
Each line corresponds to a system and is in the format of

<system id> <level count> (<size> <associativity> <line size in bytes> <replacement policy>)+

* The user needs to give each system a unique unsigned id greater than 0. 
* Replacement policy can currently be lru, which is a simplictic 
  implementation of lru.

An example cache_desc_file file that contains memory hierarchy of 
5 different systems is given at 

PMaCInstrumentor/instcode/CacheDescriptions.txt

--out-file <outfile>
====================
The path of the output C header file. An example is given at

PMaCInstrumentor/instcode/CacheStructures.h

which is generated from the cache description file 
PMaCInstrumentor/instcode/CacheDescriptions.txt.

For the cache simulation tool in PMaCInstrumentor to compile, the output
file defaults to CacheStructures.h. Thus, in PMaCInstrumentor/instcode/ 
directory, if this script is executed using a cache description file,
header file will be generated to simulate the cache structures given. 

--stride-sys <system idx>
=========================
The cache simulator in PMaCInstrumentor gather stride information for
each basic block in addition to the cache simulations. In PMaCInstrumentor,
stride information is gathered by counting the consecutive memory accesses 
that hit the same cache line independent whether the accesses hit the cache
or not. Thus, the user can give the system idx for which target cache should
be used for stride information (the system idx needs to be one of the systems
in the cache description file and the top level cache is used for the given idx). 
If not provided, a 2MB direct cache with 256-byte lines is used for 
stride information.

README_STR

sub printUsage {
    my $script_name = shift @_;
    print "$help_string\n";
    exit;
}

sub add_unique_cache {
    my ($set_count,$assoc,$line_bit_width,$repl_policy,
        $unique_cache_count,$cache_desc_to_id,$unique_caches) = @_;

    my $definition_str = "$set_count.$assoc.$line_bit_width.$repl_policy";
    if(!exists $$cache_desc_to_id{$definition_str}){
        $$cache_desc_to_id{$definition_str} = $$unique_cache_count;
        $$unique_caches[$$unique_cache_count] = [ $set_count,$assoc,$line_bit_width,$repl_policy ];
        $$unique_cache_count = $$unique_cache_count + 1;
    }
    return $$cache_desc_to_id{$definition_str};
}

sub GenerateCaches_Main {

    my $desc_field_count = 2;
    my $field_count_per_cache = 4;
    my $stride_system = undef;
    my $is_help = undef;
    my $is_readme = undef;
    my $no_use_std_funcs = undef;
    my $print_unique = undef;

    my $max_words = 0;
    my $max_assoc = 64;
    my $max_static_block = 8192;

    my $result = Getopt::Long::GetOptions (
        'sys-file=s'   => \$cache_desc_file,
        'out-file=s'   => \$output_file_name,
        'stride-sys=i' => \$stride_system,
        'help:i'       => \$is_help,
        'nostd:i'      => \$no_use_std_funcs,
        'puniq:i'      => \$print_unique,
        'readme:i'     => \$is_readme
    );

    if(!$result){
        &printUsage($0);
    }
    if(defined($is_help)){
        print "$help_string\n";
        exit;
    }
    if(defined($is_readme)){
        print "$help_string\n";
        print "$readme_string\n";
        exit;
    }

    if(defined($stride_system)){
        if($stride_system <= 0){
            print "Error : The system id needs to be > 0\n";
            &printUsage($0);
        }
    } else {
        $stride_system = 0;
    }

    print "Processing input file ---- $cache_desc_file\n";
    print "Output file will be   ---- $output_file_name\n";

    open(CACHE_FD,"<",$cache_desc_file) or die "Error: Can not open $cache_desc_file for reading\n $!";

    my $line_no = 0;
    my $sys_count = 0;

    my $stride_system_included = 0;

    my $all_cache_count = 0;
    my $unique_cache_count = 0;
    my @unique_caches;
    my %cache_desc_to_id;
    my @cache_graph;

    while(defined(my $line = <CACHE_FD>)){
        chomp($line);
        $line_no++;

        $line =~ s/#.*$//g;
        $line =~ s/^\s+//g;
        if($line eq ""){
            next;
        }

        my @tokens = split /\s+/, $line;
        if(@tokens < ($desc_field_count + $field_count_per_cache)){
            die "Error: [line $line_no] min fields are -- <sysidx> <lvlcnt> <size> <assoc> <linesz> <repl>\n";
        }

        my $sys_idx = shift @tokens;
        my $level_cnt = shift @tokens;

        if(!$sys_idx){
            die "Error: [line $line_no] System idx 0 is not allowed\n";
        }
        if(($level_cnt <= 0) || ($level_cnt > 3)){
            die "Error: [line $line_no] cache level count needs to be [1-3]\n";
        }

        if(defined($system_caches[$sys_idx])){
            die "Error: [line $line_no] System with idx $sys_idx is already defined\n";
        }
        if(@tokens != ($level_cnt * $field_count_per_cache)){
            die "Error: [line $line_no] each cache level needs $field_count_per_cache attrs not more not less\n";
        }

        if($sys_idx == $stride_system){
            $stride_system_included = 1;
        }

        my @cache_desc = ();
        push @cache_desc,$sys_idx;
        push @cache_desc,$level_cnt;

        #printf "%2d",$sys_idx;
        #printf "%5d",$level_cnt;

        for(my $i=0;$i<$level_cnt;$i++){
            my $lvl = $i + 1;
            my $size_string = shift @tokens;
            my $set_count = 0;
            my $assoc = shift @tokens;
            my $line_size = shift @tokens;
            my $repl_policy = shift @tokens;
            $repl_policy = lc $repl_policy;
            
### VICTIM_CACHE added support for a replacement policy based on victim caches called lru_vc
            if(($repl_policy ne "lru") && ($repl_policy ne "ran") && ($repl_policy ne "dir") && ($repl_policy ne "lru_vc")){
                die "Error: [line $line_no] replacement policy must be [lru|ran|dir|lru_vc]\n";
            }

            my $line_bit_width = powerOfTwo($line_size);
            if($line_bit_width < 0){
                die "Error: [line $line_no] Line size needs to be power of 2 (in bytes)\n";
            }

            if($size_string =~ /(\d+)(.*)/){
                my $int_value = $1;
                my $str_value = $2;
                my $cache_size = $int_value;
                if((lc $str_value) eq "kb"){
                    $cache_size = $cache_size * 1024;
                } elsif((lc $str_value) eq "mb"){
                    $cache_size = $cache_size * 1024 * 1024;
                } elsif($str_value eq ""){
                    $cache_size = $cache_size;
                } else {
                    die "Error: [line $line_no] size is not valid\n";
                }
                $set_count = $cache_size / ($line_size * $assoc);
                if($cache_size % ($line_size * $assoc)){
                    $set_count = int($set_count);
                    warn "Warning: [line $line_no] lvl $lvl is not divisble by lineXassoc (new count $set_count)\n";
                }
                #if($cache_size % 1024){
                #    printf "%13d", $cache_size;
                #} else {
                #    printf "%13s", ($cache_size/1024)."KB";
                #}
                #printf "%6d", $assoc;
                #printf "%7d", $line_size;
                #printf "%10s",$repl_policy;

            } else {
                die "Error: [line $line_no] at $lvl th level, size is not a valid string\n";
            }
            if(!$set_count || !$assoc || !$line_size){
                die "Error: [line $line_no] either set_count or assoc or line_size is 0 for level $lvl. Please do not use . in numbers\n";
            }
            push @cache_desc,$set_count;
            push @cache_desc,$assoc;
            push @cache_desc,$line_bit_width;
            push @cache_desc,$repl_policy;

            my $unique_id = &add_unique_cache($set_count,$assoc,$line_bit_width,$repl_policy,
                             \$unique_cache_count,\%cache_desc_to_id,\@unique_caches);
            $cache_graph[$sys_idx][$i] = $unique_id;
            $all_cache_count++;
        }
        #print "\n";

### VICTIM_CACHE make sure anything that uses the repl_lru_vc policy has the same number of sets
###              and that the last level of a cache is not considered a victim cache

        die "Error: [line $line_no] the last level of a cache cannot use lru_vc\n"
            if($cache_desc[-1] =~ /^lru_vc$/);

        my $numsets = 0;
        for (my $i = 0; $i < $cache_desc[1]; $i++){
            if ($cache_desc[5+($i*$field_count_per_cache)] =~ /^lru_vc$/){
                my $sets = $cache_desc[2+($i*$field_count_per_cache)];
                 if ($numsets == 0){
                    $numsets = $sets;
                } else {
                    die "Error: [line $line_no] all victim cache levels must have the same number of sets"
                        unless $numsets == $sets;
                }
            }
        }

        $system_caches[$sys_idx] = [ @cache_desc ];
        $sys_count++;
    }

    my @cache_desc = ();
    if(!$stride_system){
        push @cache_desc,$stride_system;
        push @cache_desc,1;
        push @cache_desc,8192;
        push @cache_desc,1;
        my $line_bit_width = powerOfTwo(256);
        push @cache_desc,$line_bit_width;
        push @cache_desc,"dir";
        $system_caches[$stride_system] = [ @cache_desc ];
        $sys_count++;
        $stride_system_included = 1;

        my $unique_id = &add_unique_cache(8192,1,$line_bit_width,"dir",
                         \$unique_cache_count,\%cache_desc_to_id,\@unique_caches);
        $cache_graph[$stride_system][0] = $unique_id;
    }
    if(defined($print_unique)){
        printf "Total Caches : $all_cache_count / Unique Caches : $unique_cache_count\n";
    }


    if(!$stride_system_included){
        die "Error: $stride_system system is chosen for stride and not included\n";
    }

    close(CACHE_FD) or die "Error: Can not close $cache_desc_file for reading\n $!";

    open(OUT_FD,">",$output_file_name) or die "Error: Can not open $output_file_name for reading\n $!";

    print OUT_FD "#ifndef _CacheStructures_h_\n";
    print OUT_FD "#define _CacheStructures_h_\n";
    print OUT_FD "\n";
    print OUT_FD "/* Note : */\n";
    print OUT_FD "/*        this file is generated by $0 script */\n";
    print OUT_FD "/*        using source as $cache_desc_file */\n";
    print OUT_FD "\n";
    print OUT_FD "#define __STRIDE_TARGET_SYSTEM $stride_system\n";
    print OUT_FD "\n";
    print OUT_FD "#define __SYSTEM_COUNT $sys_count\n";
    print OUT_FD "uint8_t systemCount =  __SYSTEM_COUNT;\n";
    print OUT_FD "MemoryHierarchy systems[__SYSTEM_COUNT] = {\n";

    for(my $j=0;$j<@system_caches;$j++){
        if(!defined($system_caches[$j])){
            next;
        }

        my @cache_desc = @{ $system_caches[$j] };
        if($stride_system == $cache_desc[0]){
            print OUT_FD "\t{      /* <------ STRIDE SYSTEM */\n";
        } else {
            print OUT_FD "\t{\n";
        }
        printf OUT_FD "\t  %3d, /* sysid%d */\n",$cache_desc[0],$cache_desc[0];
        printf OUT_FD "\t  %3d, /* cache level count */\n",$cache_desc[1];
        print OUT_FD "\t    {\n";
        my $level_cnt = $cache_desc[1];
        for(my $i=0;$i<$level_cnt;$i++){
            my $lvl = $i + 1;
            my $start_idx = $desc_field_count + ($i * $field_count_per_cache);
            printf OUT_FD "\t    { { %6d, %3d, %3d, %8s }, {0, 0}, 0, NULL, NULL }",
                        $cache_desc[$start_idx],$cache_desc[$start_idx+1],
                        $cache_desc[$start_idx+2],
                        "repl_" . $cache_desc[$start_idx+3];
            if($i < ($level_cnt - 1)){
                print OUT_FD ", /* level $lvl cache */\n";
            } else {
                print OUT_FD "  /* level $lvl cache */\n";
            }
            if($cache_desc[$start_idx+1] >= $max_assoc){
                $max_words += (5*($cache_desc[$start_idx] * $cache_desc[$start_idx+1]));
            } else {
                $max_words += ($cache_desc[$start_idx] * $cache_desc[$start_idx+1]);
            }
            $max_words += $cache_desc[$start_idx];
        }
        print OUT_FD "\t    }\n";
        if($j < (@system_caches-1)){
            print OUT_FD "\t},\n";
        } else {
            print OUT_FD "\t}\n";
        }
    }

    print OUT_FD "};\n";
    print OUT_FD "\n";

    if(defined($no_use_std_funcs)){
        print OUT_FD "\n";
        print OUT_FD "#define USE_SAFE_STD_FUNCTIONS\n";
        print OUT_FD "#define __MAX_LINEAR_SEARCH_ASSOC $max_assoc\n";
        print OUT_FD "#define __MAX_CACHE_AREA $max_words\n";
        print OUT_FD "#define __MAX_STATIC_BLOCK_COUNT $max_static_block\n";
        print OUT_FD "\n";
    }

    print OUT_FD "#endif\n";

    close(OUT_FD) or die "Error: Can not close $output_file_name for writing\n $!";

    if(defined($print_unique)){
        printf "Unique Cache ---- unique_id : { set_count assoc_count line_in_bits repl }\n";
        for(my $j=0;$j<@unique_caches;$j++){
            printf "Unique Cache : %3d { %6d %6d %6d %8s }\n",
                $j,$unique_caches[$j][0],$unique_caches[$j][1],
                $unique_caches[$j][2], "repl_" . $unique_caches[$j][3];
        }
        printf "System Info ---- system_idx : level : { unique_cache_ids }\n";
        for(my $j=0;$j<@system_caches;$j++){
            if(!defined($system_caches[$j])){
                next;
            }
            my @cache_desc = @{ $system_caches[$j] };
            printf " %3d : %3d : { ",$cache_desc[0],$cache_desc[1];
            my $level_cnt = $cache_desc[1];
            my @cache_idxes;
            for(my $i=0;$i<3;$i++){
                $cache_idxes[$i] = -1;
            }
            for(my $i=0;$i<$level_cnt;$i++){
                $cache_idxes[$i] = $cache_graph[$j][$i];
            }
            for(my $i=0;$i<3;$i++){
                printf " %3d", $cache_idxes[$i];
            }
            print " }\n";
        }
    }
}

&GenerateCaches_Main;

print "\n\n*** DONE *** SUCCESS *** SUCCESS *** SUCCESS *****************\n";
